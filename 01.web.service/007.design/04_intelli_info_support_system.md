# ì§€ëŠ¥í˜• ì •ë³´ì§€ì› í‰ê°€ ì‹œìŠ¤í…œ

## ë¬¸ì„œ ì •ë³´
- ì‘ì„±ì¼: 2025-11-19
- ë²„ì „: 2.0 (í”Œë«í¼ - ì •ë³´ì§€ì› í™•ì¥)
- ëŒ€ìƒ: ìƒì‚°ì-ì†Œë¹„ì ì—°ê²° ë° ë¹„ì¦ˆë‹ˆìŠ¤ ì •ë³´ ì œê³µ

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ê¸°ë³¸ ê°œë… ì „í™˜

**ê¸°ì¡´ ê²Œì‹œíŒ** â†’ **ì§€ëŠ¥í˜• ì •ë³´ì§€ì› í”Œë«í¼**

| êµ¬ë¶„ | ê¸°ì¡´ ê²Œì‹œíŒ | ì§€ëŠ¥í˜• ì •ë³´ì§€ì› ì‹œìŠ¤í…œ |
|------|-----------|-------------------|
| ëª©ì  | ì†Œí†µ | ì†Œí†µ + ë¹„ì¦ˆë‹ˆìŠ¤ ì •ë³´ ì œê³µ |
| ëŒ“ê¸€ | ë‹¨ìˆœ ì˜ê²¬ | ì˜ê²¬ + íŒë§¤ì²˜/êµ¬ë§¤ì²˜ ì •ë³´ |
| ê¸°ëŠ¥ | ê¸€ ì‘ì„±/ì½ê¸° | ì‘ì„± + AI ë¶„ì„ + ì •ë³´ ì¶”ì²œ |
| ê°€ì¹˜ | ì»¤ë®¤ë‹ˆí‹° | ì‹¤ì§ˆì  ë¹„ì¦ˆë‹ˆìŠ¤ ì—°ê²° |

### 1.2 í•µì‹¬ ì •ë³´ì§€ì› ê¸°ëŠ¥

```
ê²Œì‹œê¸€ ì‘ì„± (ë¡œì»¬ ì¬ë°° ì‹í’ˆ ì†Œê°œ)
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        AI ë¶„ì„ ë° ì •ë³´ ì¶”ì¶œ                      â”‚
â”‚  - ì‹í’ˆ ì¢…ë¥˜ ì¸ì‹                               â”‚
â”‚  - ì›ì‚°ì§€ ì •ë³´ ì¶”ì¶œ                             â”‚
â”‚  - ìƒì‚°ê¸°ê°„/ìœ í†µê¸°í•œ íŒŒì‹±                        â”‚
â”‚  - ì´ë¯¸ì§€ì—ì„œ í’ˆì§ˆ ë¶„ì„                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        ìë™ ì •ë³´ ë§¤ì¹­ ë° ì œê³µ                    â”‚
â”‚  â‘  íŒë§¤ ê°€ëŠ¥ ì¥ì†Œ ì¶”ì²œ                          â”‚
â”‚  â‘¡ ì›ì¬ë£Œ ê³µê¸‰ì²˜ ì •ë³´                           â”‚
â”‚  â‘¢ ì‹œì¥ê°€ê²© ì •ë³´ (ì§€ì—­/ì‹œê°„ë³„)                  â”‚
â”‚  â‘£ ì ì¬ êµ¬ë§¤ì ì—°ê²° (ê¸‰ì‹ì†Œ, ì‹ë‹¹ ë“±)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        ëŒ“ê¸€ ë° ì •ë³´ ì œê³µ                         â”‚
â”‚  - ì¼ë°˜ ëŒ“ê¸€                                    â”‚
â”‚  - ì •ë³´ ì œê³µ ëŒ“ê¸€ (íŒë§¤ì²˜, ê³µê¸‰ì²˜)              â”‚
â”‚  - ê°€ê²© ì •ë³´ ëŒ“ê¸€                               â”‚
â”‚  - êµ¬ë§¤ ì˜í–¥ ëŒ“ê¸€ (ê¸‰ì‹ì†Œ, ë°”ì´ì–´)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. í™•ì¥ëœ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

### 2.1 ê²Œì‹œê¸€ í™•ì¥ (ìƒì‚°ì ì •ë³´ í¬í•¨)

```sql
-- ìƒì‚°ì ê²Œì‹œê¸€ (í™•ì¥)
CREATE TABLE producer_posts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    
    -- ê¸°ë³¸ ì •ë³´
    title VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    images JSONB,
    videos JSONB,
    
    -- ì‹í’ˆ ì •ë³´
    food_type VARCHAR(200), -- AI ìë™ ë¶„ì„
    food_category_id INTEGER REFERENCES categories(id),
    quantity DECIMAL(10, 2), -- ìƒì‚°ëŸ‰
    quantity_unit VARCHAR(20), -- kg, í†¤, ë°•ìŠ¤ ë“±
    
    -- ìƒì‚° ì •ë³´
    production_location JSONB, -- {address, city, region, coordinates}
    production_date DATE, -- ìƒì‚°/ìˆ˜í™•ì¼
    harvest_season VARCHAR(50), -- ìˆ˜í™• ì‹œê¸°
    expiry_date DATE, -- ìœ í†µê¸°í•œ
    storage_condition VARCHAR(100), -- ë³´ê´€ ì¡°ê±´
    
    -- ì›ì‚°ì§€ ì •ë³´
    origin_country VARCHAR(2),
    origin_region VARCHAR(200),
    is_local BOOLEAN DEFAULT TRUE,
    is_organic BOOLEAN DEFAULT FALSE,
    certifications JSONB, -- [HACCP, ìœ ê¸°ë†, GAP ë“±]
    
    -- ê°€ê²© ì •ë³´
    price_per_unit DECIMAL(10, 2),
    price_currency VARCHAR(3) DEFAULT 'KRW',
    price_negotiable BOOLEAN DEFAULT FALSE,
    
    -- íŒë§¤ ì˜í–¥
    is_for_sale BOOLEAN DEFAULT FALSE,
    sale_type VARCHAR(50), -- wholesale, retail, both
    min_order_quantity DECIMAL(10, 2),
    
    -- AI ë¶„ì„ ê²°ê³¼
    ai_analysis JSONB, -- {quality_score, freshness, market_demand}
    extracted_info JSONB, -- AIê°€ ì¶”ì¶œí•œ ì •ë³´
    
    -- ë§¤ì¹­ ì •ë³´
    matched_buyers JSONB, -- ì ì¬ êµ¬ë§¤ì ëª©ë¡
    matched_suppliers JSONB, -- ê´€ë ¨ ê³µê¸‰ì²˜ ëª©ë¡
    market_price_info JSONB, -- ì‹œì¥ê°€ê²© ì •ë³´
    
    -- ìƒíƒœ
    status VARCHAR(20) DEFAULT 'published',
    view_count INTEGER DEFAULT 0,
    inquiry_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_producer_posts_food_type ON producer_posts(food_type);
CREATE INDEX idx_producer_posts_location ON producer_posts USING gin(production_location);
CREATE INDEX idx_producer_posts_is_for_sale ON producer_posts(is_for_sale);

-- ëŒ“ê¸€ í™•ì¥ (ì •ë³´ ì œê³µ íƒ€ì… ì¶”ê°€)
CREATE TABLE enhanced_comments (
    id SERIAL PRIMARY KEY,
    post_id INTEGER REFERENCES producer_posts(id) ON DELETE CASCADE,
    parent_id INTEGER REFERENCES enhanced_comments(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    
    content TEXT NOT NULL,
    
    -- ëŒ“ê¸€ íƒ€ì…
    comment_type VARCHAR(50) DEFAULT 'general', 
    -- general: ì¼ë°˜ ëŒ“ê¸€
    -- sales_channel: íŒë§¤ì²˜ ì •ë³´
    -- supplier_info: ê³µê¸‰ì²˜ ì •ë³´
    -- price_info: ê°€ê²© ì •ë³´
    -- buyer_inquiry: êµ¬ë§¤ ë¬¸ì˜
    -- advice: ì¡°ì–¸/íŒ
    
    -- ì •ë³´ ì œê³µ (íƒ€ì…ë³„ ë°ì´í„°)
    info_data JSONB,
    /*
    sales_channel: {
        name: "ë†í˜‘ í•˜ë‚˜ë¡œë§ˆíŠ¸",
        contact: "02-1234-5678",
        address: "ì„œìš¸ì‹œ ê°•ë‚¨êµ¬...",
        commission: 15,
        requirements: ["HACCP í•„ìˆ˜", "ìµœì†Œ 100kg"]
    }
    supplier_info: {
        name: "ì”¨ì•— ì „ë¬¸ì ",
        product: "í† ë§ˆí†  ì”¨ì•—",
        price: 50000,
        contact: "010-1234-5678"
    }
    price_info: {
        region: "ì„œìš¸ ê°€ë½ì‹œì¥",
        date: "2025-11-19",
        price_range: {min: 3000, max: 5000},
        unit: "kg",
        source: "ë†ì‚°ë¬¼ìœ í†µì •ë³´"
    }
    buyer_inquiry: {
        organization: "ì„œìš¸ì´ˆë“±í•™êµ",
        quantity: 500,
        unit: "kg",
        frequency: "weekly",
        contact: "02-9876-5432"
    }
    */
    
    -- ê²€ì¦
    is_verified BOOLEAN DEFAULT FALSE, -- ì •ë³´ ê²€ì¦ ì—¬ë¶€
    verified_by INTEGER REFERENCES users(id),
    verified_at TIMESTAMP,
    
    -- ìœ ìš©ì„±
    helpful_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_enhanced_comments_post_id ON enhanced_comments(post_id);
CREATE INDEX idx_enhanced_comments_type ON enhanced_comments(comment_type);

-- íŒë§¤ì²˜ ì •ë³´ DB
CREATE TABLE sales_channels (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    type VARCHAR(50), -- retail, wholesale, online, restaurant, school
    
    -- ì—°ë½ì²˜
    contact_person VARCHAR(200),
    phone VARCHAR(20),
    email VARCHAR(200),
    website VARCHAR(500),
    
    -- ìœ„ì¹˜
    address TEXT,
    city VARCHAR(100),
    region VARCHAR(100),
    country VARCHAR(2),
    coordinates JSONB, -- {lat, lng}
    
    -- ê±°ë˜ ì¡°ê±´
    commission_rate DECIMAL(5, 2), -- ìˆ˜ìˆ˜ë£Œìœ¨
    min_order_quantity DECIMAL(10, 2),
    payment_terms VARCHAR(100), -- ê²°ì œ ì¡°ê±´
    delivery_terms VARCHAR(100),
    requirements JSONB, -- ["HACCP í•„ìˆ˜", "ìœ ê¸°ë† ì¸ì¦"]
    
    -- ì·¨ê¸‰ í’ˆëª©
    product_categories JSONB, -- ì·¨ê¸‰í•˜ëŠ” ì‹í’ˆ ì¹´í…Œê³ ë¦¬
    
    -- í‰ê°€
    rating_average DECIMAL(3, 2),
    review_count INTEGER DEFAULT 0,
    
    -- ìƒíƒœ
    is_active BOOLEAN DEFAULT TRUE,
    is_verified BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sales_channels_type ON sales_channels(type);
CREATE INDEX idx_sales_channels_region ON sales_channels(region);

-- ì›ì¬ë£Œ ê³µê¸‰ì²˜ ì •ë³´
CREATE TABLE material_suppliers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    type VARCHAR(50), -- seed, fertilizer, equipment, packaging
    
    -- ì—°ë½ì²˜
    contact_person VARCHAR(200),
    phone VARCHAR(20),
    email VARCHAR(200),
    
    -- ìœ„ì¹˜
    address TEXT,
    region VARCHAR(100),
    
    -- ì œê³µ í’ˆëª©
    products JSONB, 
    /*
    [{
        name: "í† ë§ˆí†  ì”¨ì•—",
        variety: "ëŒ€ì¶”ë°©ìš¸í† ë§ˆí† ",
        price: 50000,
        unit: "1kg",
        min_order: 10
    }]
    */
    
    -- í‰ê°€
    rating_average DECIMAL(3, 2),
    
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- ì‹œì¥ ê°€ê²© ì •ë³´
CREATE TABLE market_prices (
    id SERIAL PRIMARY KEY,
    food_type VARCHAR(200) NOT NULL,
    food_variety VARCHAR(200), -- í’ˆì¢…
    
    -- ê°€ê²© ì •ë³´
    price_min DECIMAL(10, 2),
    price_max DECIMAL(10, 2),
    price_average DECIMAL(10, 2),
    unit VARCHAR(20), -- kg, ë°•ìŠ¤, ë‹¨ ë“±
    
    -- ìœ„ì¹˜
    market_name VARCHAR(200), -- ê°€ë½ì‹œì¥, ë…¸ëŸ‰ì§„ìˆ˜ì‚°ì‹œì¥ ë“±
    region VARCHAR(100),
    city VARCHAR(100),
    
    -- ì‹œê°„
    price_date DATE NOT NULL,
    price_time TIME,
    season VARCHAR(20), -- spring, summer, fall, winter
    
    -- ì¶œì²˜
    data_source VARCHAR(200), -- ë†ì‚°ë¬¼ìœ í†µì •ë³´, KAMIS ë“±
    
    -- ì¶”ê°€ ì •ë³´
    supply_level VARCHAR(20), -- high, medium, low (ê³µê¸‰ëŸ‰)
    demand_level VARCHAR(20), -- high, medium, low (ìˆ˜ìš”)
    quality_grade VARCHAR(20), -- ìƒ, ì¤‘, í•˜
    
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_market_prices_food ON market_prices(food_type, price_date);
CREATE INDEX idx_market_prices_region ON market_prices(region, price_date);
CREATE INDEX idx_market_prices_date ON market_prices(price_date DESC);

-- ì ì¬ êµ¬ë§¤ì (ê¸‰ì‹ì†Œ, ì‹ë‹¹ ë“±)
CREATE TABLE potential_buyers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    type VARCHAR(50), -- school, restaurant, hotel, hospital, catering
    
    -- ì—°ë½ì²˜
    contact_person VARCHAR(200),
    phone VARCHAR(20),
    email VARCHAR(200),
    
    -- ìœ„ì¹˜
    address TEXT,
    city VARCHAR(100),
    region VARCHAR(100),
    
    -- êµ¬ë§¤ ì •ë³´
    purchase_frequency VARCHAR(50), -- daily, weekly, monthly
    average_order_volume DECIMAL(10, 2),
    preferred_categories JSONB, -- ì„ í˜¸í•˜ëŠ” ì‹í’ˆ ì¹´í…Œê³ ë¦¬
    
    -- ìš”êµ¬ì‚¬í•­
    requirements JSONB, -- ["HACCP í•„ìˆ˜", "ë¡œì»¬ ì‹í’ˆ ìš°ì„ "]
    budget_range JSONB, -- {min, max}
    
    -- ìƒíƒœ
    is_active BOOLEAN DEFAULT TRUE,
    is_verified BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_potential_buyers_type ON potential_buyers(type);
CREATE INDEX idx_potential_buyers_region ON potential_buyers(region);

-- ì •ë³´ ì œê³µ ë³´ìƒ (ì •ë³´ ì œê³µìì—ê²Œ í¬ì¸íŠ¸)
CREATE TABLE info_contribution_rewards (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    comment_id INTEGER REFERENCES enhanced_comments(id),
    contribution_type VARCHAR(50), -- sales_channel, supplier_info, price_info, buyer_inquiry
    points_earned INTEGER,
    verification_status VARCHAR(20), -- pending, verified, rejected
    created_at TIMESTAMP DEFAULT NOW()
);
```

---

## 3. AI ë¶„ì„ ë° ì •ë³´ ì¶”ì¶œ

### 3.1 ê²Œì‹œê¸€ AI ë¶„ì„ ì‹œìŠ¤í…œ

```python
# ai_analysis.py
from transformers import pipeline
import cv2
from geopy.geocoders import Nominatim

class PostAnalyzer:
    """ê²Œì‹œê¸€ AI ë¶„ì„"""
    
    def __init__(self):
        self.nlp = pipeline("ner", model="korean-ner-model")
        self.image_classifier = pipeline("image-classification")
        self.geolocator = Nominatim(user_agent="spicyjump")
    
    async def analyze_post(self, post: ProducerPostCreate):
        """ê²Œì‹œê¸€ ì¢…í•© ë¶„ì„"""
        
        analysis_result = {
            "food_info": await self.extract_food_info(post.content, post.images),
            "location_info": await self.extract_location_info(post.content),
            "production_info": await self.extract_production_info(post.content),
            "quality_assessment": await self.assess_quality(post.images),
            "market_matching": await self.match_market_info(post)
        }
        
        return analysis_result
    
    async def extract_food_info(self, content: str, images: List[str]):
        """ì‹í’ˆ ì •ë³´ ì¶”ì¶œ"""
        
        # í…ìŠ¤íŠ¸ì—ì„œ ì‹í’ˆëª… ì¶”ì¶œ
        entities = self.nlp(content)
        food_items = [e['word'] for e in entities if e['entity'] == 'FOOD']
        
        # ì´ë¯¸ì§€ ë¶„ì„ (ì‹í’ˆ ì¢…ë¥˜ íŒë³„)
        image_results = []
        for img_url in images[:3]:  # ìµœëŒ€ 3ì¥ ë¶„ì„
            img = download_image(img_url)
            result = self.image_classifier(img)
            image_results.append(result[0])
        
        return {
            "detected_foods": food_items,
            "image_classification": image_results,
            "primary_food": food_items[0] if food_items else None
        }
    
    async def extract_location_info(self, content: str):
        """ìœ„ì¹˜ ì •ë³´ ì¶”ì¶œ"""
        
        # NERë¡œ ì§€ëª… ì¶”ì¶œ
        entities = self.nlp(content)
        locations = [e['word'] for e in entities if e['entity'] == 'LOCATION']
        
        if not locations:
            return None
        
        # ì§€ì˜¤ì½”ë”©
        location = self.geolocator.geocode(locations[0])
        
        if location:
            return {
                "address": location.address,
                "coordinates": {
                    "lat": location.latitude,
                    "lng": location.longitude
                },
                "city": extract_city(location.address),
                "region": extract_region(location.address)
            }
        
        return None
    
    async def extract_production_info(self, content: str):
        """ìƒì‚° ì •ë³´ ì¶”ì¶œ (ë‚ ì§œ, ê¸°ê°„, ìˆ˜ëŸ‰ ë“±)"""
        
        import re
        from dateutil import parser
        
        # ë‚ ì§œ íŒ¨í„´ ì¶”ì¶œ
        date_patterns = re.findall(r'\d{4}[-./]\d{1,2}[-./]\d{1,2}', content)
        dates = [parser.parse(d) for d in date_patterns]
        
        # ìˆ˜ëŸ‰ ì •ë³´ ì¶”ì¶œ
        quantity_patterns = re.findall(r'(\d+(?:\.\d+)?)\s*(kg|í†¤|ë°•ìŠ¤|ê°œ)', content)
        
        # ê¸°ê°„ ì •ë³´ ì¶”ì¶œ
        period_keywords = ['ìˆ˜í™•', 'ì¬ë°°', 'ìƒì‚°']
        periods = []
        for keyword in period_keywords:
            if keyword in content:
                # í•´ë‹¹ í‚¤ì›Œë“œ ì£¼ë³€ ë‚ ì§œ ì •ë³´ ì¶”ì¶œ
                pass
        
        return {
            "dates": dates,
            "quantities": [{"value": q[0], "unit": q[1]} for q in quantity_patterns],
            "production_period": periods
        }
    
    async def assess_quality(self, images: List[str]):
        """ì´ë¯¸ì§€ ê¸°ë°˜ í’ˆì§ˆ í‰ê°€"""
        
        if not images:
            return None
        
        quality_scores = []
        
        for img_url in images[:3]:
            img = download_image(img_url)
            
            # ì‹ ì„ ë„ í‰ê°€ (ìƒ‰ìƒ, í˜•íƒœ ë¶„ì„)
            freshness = analyze_freshness(img)
            
            # í’ˆì§ˆ ì ìˆ˜
            quality_score = calculate_quality_score(img)
            
            quality_scores.append({
                "freshness": freshness,
                "quality_score": quality_score
            })
        
        avg_quality = sum(q['quality_score'] for q in quality_scores) / len(quality_scores)
        
        return {
            "average_quality": avg_quality,
            "individual_scores": quality_scores,
            "recommendation": get_quality_recommendation(avg_quality)
        }
    
    async def match_market_info(self, post: ProducerPostCreate):
        """ì‹œì¥ ì •ë³´ ë§¤ì¹­"""
        
        # 1. í˜„ì¬ ì‹œì¥ ê°€ê²© ì¡°íšŒ
        market_prices = await get_market_prices(
            food_type=post.food_type,
            region=post.location_info.get('region')
        )
        
        # 2. íŒë§¤ ê°€ëŠ¥ ì±„ë„ ì¶”ì²œ
        sales_channels = await recommend_sales_channels(
            food_type=post.food_type,
            quantity=post.quantity,
            location=post.location_info
        )
        
        # 3. ì ì¬ êµ¬ë§¤ì ë§¤ì¹­
        potential_buyers = await match_potential_buyers(
            food_type=post.food_type,
            quantity=post.quantity,
            location=post.location_info
        )
        
        return {
            "market_prices": market_prices,
            "recommended_channels": sales_channels,
            "potential_buyers": potential_buyers
        }
```

---

## 4. ì •ë³´ ì œê³µ API

### 4.1 ê²Œì‹œê¸€ ì‘ì„± ì‹œ ìë™ ì •ë³´ ì œê³µ

```python
# producer_posts_api.py
@router.post("/producer-posts")
async def create_producer_post(
    post: ProducerPostCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ìƒì‚°ì ê²Œì‹œê¸€ ì‘ì„± (AI ë¶„ì„ í¬í•¨)"""
    
    # 1. AI ë¶„ì„
    analyzer = PostAnalyzer()
    analysis = await analyzer.analyze_post(post)
    
    # 2. ê²Œì‹œê¸€ ì €ì¥
    post_id = await db.fetch_val(
        """
        INSERT INTO producer_posts (
            user_id, title, content, images, videos,
            food_type, quantity, quantity_unit,
            production_location, production_date, expiry_date,
            origin_region, is_local, is_organic, certifications,
            price_per_unit, is_for_sale, sale_type,
            ai_analysis, extracted_info
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
        RETURNING id
        """,
        current_user.id, post.title, post.content,
        json.dumps(post.images), json.dumps(post.videos),
        analysis['food_info']['primary_food'],
        post.quantity, post.quantity_unit,
        json.dumps(analysis['location_info']),
        post.production_date, post.expiry_date,
        analysis['location_info'].get('region'),
        post.is_local, post.is_organic, json.dumps(post.certifications),
        post.price_per_unit, post.is_for_sale, post.sale_type,
        json.dumps(analysis), json.dumps(analysis)
    )
    
    # 3. ì‹œì¥ ì •ë³´ ë§¤ì¹­
    matched_info = await match_and_store_info(db, post_id, analysis)
    
    # 4. ìë™ ì •ë³´ ëŒ“ê¸€ ìƒì„±
    await create_auto_info_comments(db, post_id, matched_info)
    
    # 5. ì•Œë¦¼ ë°œì†¡ (ì ì¬ êµ¬ë§¤ìì—ê²Œ)
    await notify_potential_buyers(matched_info['potential_buyers'], post_id)
    
    return {
        "id": post_id,
        "analysis": analysis,
        "matched_info": matched_info,
        "message": "ê²Œì‹œê¸€ì´ ì‘ì„±ë˜ì—ˆìœ¼ë©°, ê´€ë ¨ ì •ë³´ê°€ ìë™ìœ¼ë¡œ ì œê³µë˜ì—ˆìŠµë‹ˆë‹¤."
    }

async def create_auto_info_comments(
    db: Session,
    post_id: int,
    matched_info: dict
):
    """ìë™ ì •ë³´ ëŒ“ê¸€ ìƒì„±"""
    
    system_user_id = 1  # ì‹œìŠ¤í…œ ë´‡ ì‚¬ìš©ì
    
    # 1. íŒë§¤ì²˜ ì •ë³´ ëŒ“ê¸€
    if matched_info.get('sales_channels'):
        for channel in matched_info['sales_channels'][:3]:
            await db.execute(
                """
                INSERT INTO enhanced_comments (
                    post_id, user_id, content, comment_type, info_data, is_verified
                ) VALUES ($1, $2, $3, $4, $5, TRUE)
                """,
                post_id, system_user_id,
                f"ğŸ’¼ ì¶”ì²œ íŒë§¤ì²˜: {channel['name']}",
                'sales_channel',
                json.dumps(channel)
            )
    
    # 2. ì‹œì¥ ê°€ê²© ì •ë³´ ëŒ“ê¸€
    if matched_info.get('market_prices'):
        price_info = matched_info['market_prices'][0]
        await db.execute(
            """
            INSERT INTO enhanced_comments (
                post_id, user_id, content, comment_type, info_data, is_verified
            ) VALUES ($1, $2, $3, $4, $5, TRUE)
            """,
            post_id, system_user_id,
            f"ğŸ“Š í˜„ì¬ ì‹œì¥ê°€ê²©: {price_info['market_name']} {price_info['price_average']:,}ì›/{price_info['unit']}",
            'price_info',
            json.dumps(price_info)
        )
    
    # 3. ì ì¬ êµ¬ë§¤ì ì •ë³´ ëŒ“ê¸€
    if matched_info.get('potential_buyers'):
        for buyer in matched_info['potential_buyers'][:2]:
            await db.execute(
                """
                INSERT INTO enhanced_comments (
                    post_id, user_id, content, comment_type, info_data, is_verified
                ) VALUES ($1, $2, $3, $4, $5, TRUE)
                """,
                post_id, system_user_id,
                f"ğŸ« ì ì¬ êµ¬ë§¤ì²˜: {buyer['name']} ({buyer['type']})",
                'buyer_inquiry',
                json.dumps(buyer)
            )
```

### 4.2 íŒë§¤ì²˜ ì •ë³´ ì œê³µ API

```python
# sales_channels_api.py
@router.get("/sales-channels/recommend")
async def recommend_sales_channels(
    food_type: str,
    region: Optional[str] = None,
    quantity: Optional[float] = None,
    db: Session = Depends(get_db)
):
    """íŒë§¤ì²˜ ì¶”ì²œ"""
    
    query = """
        SELECT * FROM sales_channels
        WHERE is_active = TRUE
        AND is_verified = TRUE
        AND $1 = ANY(product_categories)
    """
    
    params = [food_type]
    
    if region:
        query += " AND region = $2"
        params.append(region)
    
    if quantity:
        query += f" AND (min_order_quantity IS NULL OR min_order_quantity <= ${len(params) + 1})"
        params.append(quantity)
    
    query += " ORDER BY rating_average DESC LIMIT 10"
    
    channels = await db.fetch_all(query, *params)
    
    return [
        {
            **channel,
            "match_score": calculate_match_score(channel, food_type, region, quantity)
        }
        for channel in channels
    ]

@router.post("/enhanced-comments/sales-channel")
async def add_sales_channel_comment(
    post_id: int,
    channel_info: SalesChannelInfo,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """íŒë§¤ì²˜ ì •ë³´ ëŒ“ê¸€ ì‘ì„±"""
    
    comment_id = await db.execute(
        """
        INSERT INTO enhanced_comments (
            post_id, user_id, content, comment_type, info_data
        ) VALUES ($1, $2, $3, 'sales_channel', $4)
        RETURNING id
        """,
        post_id, current_user.id,
        f"ğŸ’¼ íŒë§¤ì²˜ ì •ë³´: {channel_info.name}",
        json.dumps(channel_info.dict())
    )
    
    # ì •ë³´ ì œê³µ ë³´ìƒ (í¬ì¸íŠ¸ ì§€ê¸‰)
    await grant_info_contribution_reward(
        db, current_user.id, comment_id, 'sales_channel', 50
    )
    
    return {"id": comment_id, "reward_points": 50}
```

### 4.3 ì›ì¬ë£Œ ê³µê¸‰ì²˜ ì •ë³´ API

```python
# suppliers_api.py
@router.get("/material-suppliers/search")
async def search_suppliers(
    product_type: str,  # seed, fertilizer, equipment
    region: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """ì›ì¬ë£Œ ê³µê¸‰ì²˜ ê²€ìƒ‰"""
    
    suppliers = await db.fetch_all(
        """
        SELECT * FROM material_suppliers
        WHERE type = $1
        AND ($2 IS NULL OR region = $2)
        AND is_active = TRUE
        ORDER BY rating_average DESC
        """,
        product_type, region
    )
    
    return suppliers

@router.post("/enhanced-comments/supplier-info")
async def add_supplier_info_comment(
    post_id: int,
    supplier_info: SupplierInfo,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ê³µê¸‰ì²˜ ì •ë³´ ëŒ“ê¸€ ì‘ì„±"""
    
    comment_id = await db.execute(
        """
        INSERT INTO enhanced_comments (
            post_id, user_id, content, comment_type, info_data
        ) VALUES ($1, $2, $3, 'supplier_info', $4)
        RETURNING id
        """,
        post_id, current_user.id,
        f"ğŸŒ± ì›ì¬ë£Œ ê³µê¸‰ì²˜: {supplier_info.name} - {supplier_info.product}",
        json.dumps(supplier_info.dict())
    )
    
    # ë³´ìƒ
    await grant_info_contribution_reward(
        db, current_user.id, comment_id, 'supplier_info', 30
    )
    
    return {"id": comment_id, "reward_points": 30}
```

### 4.4 ì‹œì¥ ê°€ê²© ì •ë³´ API

```python
# market_prices_api.py
@router.get("/market-prices/current")
async def get_current_market_prices(
    food_type: str,
    region: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """í˜„ì¬ ì‹œì¥ ê°€ê²© ì¡°íšŒ"""
    
    # ìµœê·¼ 7ì¼ í‰ê· 
    prices = await db.fetch_all(
        """
        SELECT 
            market_name,
            region,
            AVG(price_average) as avg_price,
            MIN(price_min) as min_price,
            MAX(price_max) as max_price,
            unit,
            MAX(price_date) as latest_date
        FROM market_prices
        WHERE food_type = $1
        AND ($2 IS NULL OR region = $2)
        AND price_date >= CURRENT_DATE - INTERVAL '7 days'
        GROUP BY market_name, region, unit
        ORDER BY latest_date DESC
        """,
        food_type, region
    )
    
    return prices

@router.get("/market-prices/trend")
async def get_price_trend(
    food_type: str,
    region: str,
    days: int = 30,
    db: Session = Depends(get_db)
):
    """ê°€ê²© ì¶”ì´ ì¡°íšŒ"""
    
    trend = await db.fetch_all(
        """
        SELECT 
            price_date,
            AVG(price_average) as avg_price,
            supply_level,
            demand_level
        FROM market_prices
        WHERE food_type = $1
        AND region = $2
        AND price_date >= CURRENT_DATE - INTERVAL '$3 days'
        GROUP BY price_date, supply_level, demand_level
        ORDER BY price_date ASC
        """,
        food_type, region, days
    )
    
    # ì¶”ì„¸ ë¶„ì„
    analysis = analyze_price_trend(trend)
    
    return {
        "data": trend,
        "analysis": analysis,
        "recommendation": generate_price_recommendation(analysis)
    }

def generate_price_recommendation(analysis: dict) -> str:
    """ê°€ê²© ê¸°ë°˜ ì¶”ì²œ"""
    
    if analysis['trend'] == 'increasing' and analysis['rate'] > 10:
        return "ê°€ê²©ì´ ìƒìŠ¹ ì¶”ì„¸ì…ë‹ˆë‹¤. ì§€ê¸ˆ íŒë§¤í•˜ì‹œë©´ ì¢‹ì€ ê°€ê²©ì„ ë°›ìœ¼ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤."
    elif analysis['trend'] == 'decreasing':
        return "ê°€ê²©ì´ í•˜ë½ ì¶”ì„¸ì…ë‹ˆë‹¤. ê°€ëŠ¥í•˜ë©´ ë¹ ë¥¸ íŒë§¤ë¥¼ ê¶Œì¥ë“œë¦½ë‹ˆë‹¤."
    elif analysis['supply'] == 'low' and analysis['demand'] == 'high':
        return "ê³µê¸‰ì´ ë¶€ì¡±í•˜ê³  ìˆ˜ìš”ê°€ ë†’ìŠµë‹ˆë‹¤. í”„ë¦¬ë¯¸ì—„ ê°€ê²©ì„ ì±…ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
    else:
        return "ì‹œì¥ ê°€ê²©ì´ ì•ˆì •ì ì…ë‹ˆë‹¤. ì ì • ê°€ê²©ìœ¼ë¡œ íŒë§¤í•˜ì„¸ìš”."

@router.post("/enhanced-comments/price-info")
async def add_price_info_comment(
    post_id: int,
    price_info: PriceInfo,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ê°€ê²© ì •ë³´ ëŒ“ê¸€ ì‘ì„±"""
    
    comment_id = await db.execute(
        """
        INSERT INTO enhanced_comments (
            post_id, user_id, content, comment_type, info_data
        ) VALUES ($1, $2, $3, 'price_info', $4)
        RETURNING id
        """,
        post_id, current_user.id,
        f"ğŸ“Š {price_info.market_name} ì‹œì¥ê°€ê²©: {price_info.price_range['min']:,}~{price_info.price_range['max']:,}ì›/{price_info.unit}",
        json.dumps(price_info.dict())
    )
    
    await grant_info_contribution_reward(
        db, current_user.id, comment_id, 'price_info', 20
    )
    
    return {"id": comment_id, "reward_points": 20}
```

### 4.5 ì ì¬ êµ¬ë§¤ì ë§¤ì¹­ API

```python
# buyers_matching_api.py
@router.get("/potential-buyers/match")
async def match_potential_buyers(
    food_type: str,
    region: str,
    quantity: float,
    db: Session = Depends(get_db)
):
    """ì ì¬ êµ¬ë§¤ì ë§¤ì¹­"""
    
    buyers = await db.fetch_all(
        """
        SELECT * FROM potential_buyers
        WHERE is_active = TRUE
        AND is_verified = TRUE
        AND region = $1
        AND $2 = ANY(preferred_categories)
        AND (average_order_volume >= $3 * 0.5)  -- ìˆ˜ëŸ‰ì˜ 50% ì´ìƒ êµ¬ë§¤ ê°€ëŠ¥
        ORDER BY average_order_volume DESC
        """,
        region, food_type, quantity
    )
    
    return [
        {
            **buyer,
            "match_score": calculate_buyer_match_score(buyer, food_type, quantity),
            "estimated_purchase_volume": estimate_purchase_volume(buyer, quantity)
        }
        for buyer in buyers
    ]

@router.post("/enhanced-comments/buyer-inquiry")
async def add_buyer_inquiry_comment(
    post_id: int,
    buyer_info: BuyerInquiry,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """êµ¬ë§¤ ë¬¸ì˜ ëŒ“ê¸€ ì‘ì„±"""
    
    comment_id = await db.execute(
        """
        INSERT INTO enhanced_comments (
            post_id, user_id, content, comment_type, info_data
        ) VALUES ($1, $2, $3, 'buyer_inquiry', $4)
        RETURNING id
        """,
        post_id, current_user.id,
        f"ğŸ« êµ¬ë§¤ ë¬¸ì˜: {buyer_info.organization} - {buyer_info.quantity}{buyer_info.unit} êµ¬ë§¤ í¬ë§",
        json.dumps(buyer_info.dict())
    )
    
    # ê²Œì‹œê¸€ ì‘ì„±ìì—ê²Œ ì•Œë¦¼
    post = await db.fetch_one("SELECT user_id FROM producer_posts WHERE id = $1", post_id)
    await send_notification(
        user_id=post['user_id'],
        type='buyer_inquiry',
        data={'comment_id': comment_id, 'buyer': buyer_info.organization}
    )
    
    return {"id": comment_id, "message": "êµ¬ë§¤ ë¬¸ì˜ê°€ ì „ë‹¬ë˜ì—ˆìŠµë‹ˆë‹¤."}
```

---

## 5. Frontend ì»´í¬ë„ŒíŠ¸

### 5.1 ì •ë³´ ì œê³µ ëŒ“ê¸€ ì»´í¬ë„ŒíŠ¸

```tsx
// InfoCommentCard.tsx
interface InfoCommentProps {
  comment: EnhancedComment;
  onContact: (info: any) => void;
}

export const InfoCommentCard: React.FC<InfoCommentProps> = ({
  comment,
  onContact
}) => {
  const renderInfoContent = () => {
    switch (comment.comment_type) {
      case 'sales_channel':
        return (
          <SalesChannelInfo>
            <InfoIcon>ğŸ’¼</InfoIcon>
            <InfoContent>
              <InfoTitle>íŒë§¤ì²˜ ì •ë³´</InfoTitle>
              <CompanyName>{comment.info_data.name}</CompanyName>
              <InfoDetails>
                <DetailItem>
                  <Label>ì—°ë½ì²˜:</Label>
                  <Value>{comment.info_data.contact}</Value>
                </DetailItem>
                <DetailItem>
                  <Label>ì£¼ì†Œ:</Label>
                  <Value>{comment.info_data.address}</Value>
                </DetailItem>
                <DetailItem>
                  <Label>ìˆ˜ìˆ˜ë£Œ:</Label>
                  <Value>{comment.info_data.commission}%</Value>
                </DetailItem>
                <DetailItem>
                  <Label>ìµœì†Œì£¼ë¬¸:</Label>
                  <Value>{comment.info_data.requirements?.join(', ')}</Value>
                </DetailItem>
              </InfoDetails>
              <ContactButton onClick={() => onContact(comment.info_data)}>
                <PhoneIcon /> ì—°ë½í•˜ê¸°
              </ContactButton>
            </InfoContent>
          </SalesChannelInfo>
        );
      
      case 'supplier_info':
        return (
          <SupplierInfo>
            <InfoIcon>ğŸŒ±</InfoIcon>
            <InfoContent>
              <InfoTitle>ì›ì¬ë£Œ ê³µê¸‰ì²˜</InfoTitle>
              <CompanyName>{comment.info_data.name}</CompanyName>
              <ProductInfo>
                {comment.info_data.product} - {formatCurrency(comment.info_data.price)}
              </ProductInfo>
              <ContactButton onClick={() => onContact(comment.info_data)}>
                ë¬¸ì˜í•˜ê¸°
              </ContactButton>
            </InfoContent>
          </SupplierInfo>
        );
      
      case 'price_info':
        return (
          <PriceInfo>
            <InfoIcon>ğŸ“Š</InfoIcon>
            <InfoContent>
              <InfoTitle>ì‹œì¥ ê°€ê²© ì •ë³´</InfoTitle>
              <MarketName>{comment.info_data.market_name}</MarketName>
              <PriceRange>
                <MinPrice>{formatCurrency(comment.info_data.price_range.min)}</MinPrice>
                <Separator>~</Separator>
                <MaxPrice>{formatCurrency(comment.info_data.price_range.max)}</MaxPrice>
                <Unit>/ {comment.info_data.unit}</Unit>
              </PriceRange>
              <PriceDate>
                ê¸°ì¤€ì¼: {formatDate(comment.info_data.date)}
              </PriceDate>
            </InfoContent>
          </PriceInfo>
        );
      
      case 'buyer_inquiry':
        return (
          <BuyerInquiry>
            <InfoIcon>ğŸ«</InfoIcon>
            <InfoContent>
              <InfoTitle>êµ¬ë§¤ ë¬¸ì˜</InfoTitle>
              <OrganizationName>{comment.info_data.organization}</OrganizationName>
              <InquiryDetails>
                <DetailItem>
                  <Label>í¬ë§ ìˆ˜ëŸ‰:</Label>
                  <Value>{comment.info_data.quantity} {comment.info_data.unit}</Value>
                </DetailItem>
                <DetailItem>
                  <Label>êµ¬ë§¤ ì£¼ê¸°:</Label>
                  <Value>{comment.info_data.frequency}</Value>
                </DetailItem>
                <DetailItem>
                  <Label>ì—°ë½ì²˜:</Label>
                  <Value>{comment.info_data.contact}</Value>
                </DetailItem>
              </InquiryDetails>
              <ResponseButton onClick={() => handleResponse(comment)}>
                ê²¬ì  ì œê³µí•˜ê¸°
              </ResponseButton>
            </InfoContent>
          </BuyerInquiry>
        );
      
      default:
        return <p>{comment.content}</p>;
    }
  };
  
  return (
    <CommentCard verified={comment.is_verified}>
      {comment.is_verified && (
        <VerifiedBadge>
          <CheckIcon /> ê²€ì¦ëœ ì •ë³´
        </VerifiedBadge>
      )}
      
      {renderInfoContent()}
      
      <CommentFooter>
        <Author>
          <Avatar src={comment.user.avatar} />
          <AuthorName>{comment.user.name}</AuthorName>
        </Author>
        <Actions>
          <HelpfulButton onClick={() => markHelpful(comment.id)}>
            <ThumbsUpIcon /> ë„ì›€ë¨ {comment.helpful_count}
          </HelpfulButton>
        </Actions>
      </CommentFooter>
    </CommentCard>
  );
};
```

### 5.2 ì‹œì¥ ê°€ê²© ìœ„ì ¯

```tsx
// MarketPriceWidget.tsx
export const MarketPriceWidget: React.FC<{ foodType: string; region: string }> = ({
  foodType,
  region
}) => {
  const { data: priceData } = useQuery(
    ['market-prices', foodType, region],
    () => api.get(`/market-prices/current?food_type=${foodType}&region=${region}`)
  );
  
  const { data: trendData } = useQuery(
    ['price-trend', foodType, region],
    () => api.get(`/market-prices/trend?food_type=${foodType}&region=${region}&days=30`)
  );
  
  return (
    <PriceWidgetContainer>
      <WidgetHeader>
        <h3>ğŸ“Š í˜„ì¬ ì‹œì¥ ê°€ê²©</h3>
        <RefreshButton onClick={refetch}>
          <RefreshIcon />
        </RefreshButton>
      </WidgetHeader>
      
      <PriceList>
        {priceData?.map(price => (
          <PriceItem key={price.market_name}>
            <MarketName>{price.market_name}</MarketName>
            <PriceValue>
              {formatCurrency(price.avg_price)} / {price.unit}
            </PriceValue>
            <PriceRange>
              ({formatCurrency(price.min_price)} ~ {formatCurrency(price.max_price)})
            </PriceRange>
          </PriceItem>
        ))}
      </PriceList>
      
      {trendData && (
        <TrendSection>
          <h4>30ì¼ ê°€ê²© ì¶”ì´</h4>
          <LineChart data={trendData.data} />
          <Recommendation>{trendData.recommendation}</Recommendation>
        </TrendSection>
      )}
    </PriceWidgetContainer>
  );
};
```

---

**ë¬¸ì„œ ê´€ë¦¬**
- ì‘ì„±ì: ì¥ì¬í›ˆ
- ìµœì¢… ì—…ë°ì´íŠ¸: 2025-11-19
- ì—°ê´€ ë¬¸ì„œ: í‰ê°€ê´€ë¦¬ CMS ì‹œìŠ¤í…œ, í”Œë«í¼ ì•„í‚¤í…ì²˜


