# í‰ê°€ê´€ë¦¬ ë° CMS ì‹œìŠ¤í…œ ì„¤ê³„

## ë¬¸ì„œ ì •ë³´
- ì‘ì„±ì¼: 2025-11-19
- ë²„ì „: 2.0 (í”Œë«í¼)
- ëŒ€ìƒ: í‰ê°€, ëŒ“ê¸€, ì½˜í…ì¸  ê´€ë¦¬ ì‹œìŠ¤í…œ

---

## 1. í‰ê°€ê´€ë¦¬ ì‹œìŠ¤í…œ ê°œìš”

### 1.1 í•µì‹¬ ê¸°ëŠ¥
- **ê°ì •í‰ê°€**: ì¢‹ì•„ìš”, ì‹«ì–´ìš”, ë„ì›€ë¨, ê³µê° ë“±
- **ë¦¬ë·°/ëŒ“ê¸€**: ìƒí’ˆ ë¦¬ë·°, ê²Œì‹œê¸€ ëŒ“ê¸€, ëŒ€ëŒ“ê¸€
- **í‰ì **: 5ì  ì²™ë„, ì„¸ë¶€ í•­ëª©ë³„ í‰ì 
- **CMS**: ê²Œì‹œê¸€ ì‘ì„±, í¸ì§‘, ì´ë¯¸ì§€ ì—…ë¡œë“œ
- **ì—°ê³„**: ë¼ë²¨ë§/ë¦¬ì›Œë“œ, ê±°ë˜(ë¸”ë¡ì²´ì¸), ê²°ì œì™€ ë°ì´í„° ë§¤í•‘

### 1.2 ì‹œìŠ¤í…œ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Frontend Layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ ë¦¬ë·° ì‘ì„±  â”‚  â”‚ ëŒ“ê¸€ ì‹œìŠ¤í…œ â”‚  â”‚ ê²Œì‹œê¸€ ì‘ì„± â”‚         â”‚
â”‚  â”‚ ê°ì •í‰ê°€   â”‚  â”‚ ëŒ€ëŒ“ê¸€      â”‚  â”‚ ì´ë¯¸ì§€í¸ì§‘  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Backend API Layer                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ í‰ê°€ API   â”‚  â”‚ ëŒ“ê¸€ API   â”‚  â”‚ CMS API    â”‚         â”‚
â”‚  â”‚ ê°ì • API   â”‚  â”‚ ì•Œë¦¼ API   â”‚  â”‚ ë¯¸ë””ì–´ API â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Data Mapping Layer                      â”‚
â”‚  ë¦¬ë·° â†â†’ ê±°ë˜(ë¸”ë¡ì²´ì¸) â†â†’ ê²°ì œ â†â†’ ë¦¬ì›Œë“œ               â”‚
â”‚  í‰ê°€ â†â†’ ë¼ë²¨ë§ â†â†’ AI í•™ìŠµ ë°ì´í„°                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Database Layer                         â”‚
â”‚  reviews, comments, reactions, posts, media              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

### 2.1 ë¦¬ë·° ë° í‰ê°€ í…Œì´ë¸”

```sql
-- ë¦¬ë·° í…Œì´ë¸” (í™•ì¥)
CREATE TABLE reviews (
    id SERIAL PRIMARY KEY,
    product_id INTEGER REFERENCES products(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    order_id INTEGER REFERENCES orders(id) ON DELETE SET NULL,
    transaction_id INTEGER REFERENCES transactions(id), -- ê±°ë˜ ì—°ê²°
    payment_id INTEGER REFERENCES payments(id), -- ê²°ì œ ì—°ê²°
    
    -- í‰ì 
    rating_overall INTEGER CHECK (rating_overall >= 1 AND rating_overall <= 5),
    rating_quality INTEGER CHECK (rating_quality >= 1 AND rating_quality <= 5),
    rating_delivery INTEGER CHECK (rating_delivery >= 1 AND rating_delivery <= 5),
    rating_packaging INTEGER CHECK (rating_packaging >= 1 AND rating_packaging <= 5),
    
    -- ë‚´ìš©
    title VARCHAR(200),
    content TEXT NOT NULL,
    pros TEXT, -- ì¥ì 
    cons TEXT, -- ë‹¨ì 
    
    -- ë¯¸ë””ì–´
    images JSONB, -- [{url, caption, order}]
    videos JSONB, -- [{url, thumbnail, duration}]
    
    -- ë©”íƒ€
    is_verified_purchase BOOLEAN DEFAULT FALSE,
    is_featured BOOLEAN DEFAULT FALSE, -- ë² ìŠ¤íŠ¸ ë¦¬ë·°
    helpful_count INTEGER DEFAULT 0,
    unhelpful_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    
    -- ìƒíƒœ
    status VARCHAR(20) DEFAULT 'published', -- draft, published, hidden, flagged, deleted
    moderation_status VARCHAR(20) DEFAULT 'pending', -- pending, approved, rejected
    moderation_reason TEXT,
    moderated_by INTEGER REFERENCES users(id),
    moderated_at TIMESTAMP,
    
    -- ë¦¬ì›Œë“œ ì—°ê²°
    reward_points_earned INTEGER DEFAULT 0,
    reward_transaction_id INTEGER,
    
    -- ë¸”ë¡ì²´ì¸ ì—°ê²°
    blockchain_hash VARCHAR(255), -- ë¦¬ë·° ìœ„ë³€ì¡° ë°©ì§€
    blockchain_verified BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deleted_at TIMESTAMP
);

CREATE INDEX idx_reviews_product_id ON reviews(product_id);
CREATE INDEX idx_reviews_user_id ON reviews(user_id);
CREATE INDEX idx_reviews_transaction_id ON reviews(transaction_id);
CREATE INDEX idx_reviews_status ON reviews(status);
CREATE INDEX idx_reviews_rating ON reviews(rating_overall DESC);
CREATE INDEX idx_reviews_created_at ON reviews(created_at DESC);

-- ëŒ“ê¸€ í…Œì´ë¸”
CREATE TABLE comments (
    id SERIAL PRIMARY KEY,
    parent_id INTEGER REFERENCES comments(id) ON DELETE CASCADE, -- ëŒ€ëŒ“ê¸€
    target_type VARCHAR(50) NOT NULL, -- review, post, product
    target_id INTEGER NOT NULL,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    
    content TEXT NOT NULL,
    images JSONB, -- ëŒ“ê¸€ì— ì´ë¯¸ì§€ ì²¨ë¶€
    
    -- ê°ì •í‰ê°€
    like_count INTEGER DEFAULT 0,
    dislike_count INTEGER DEFAULT 0,
    
    -- ìƒíƒœ
    status VARCHAR(20) DEFAULT 'published',
    is_pinned BOOLEAN DEFAULT FALSE, -- ê³ ì • ëŒ“ê¸€
    is_author_reply BOOLEAN DEFAULT FALSE, -- ì‘ì„±ì ë‹µê¸€
    
    -- ë¸”ë¡ì²´ì¸
    blockchain_hash VARCHAR(255),
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deleted_at TIMESTAMP
);

CREATE INDEX idx_comments_target ON comments(target_type, target_id);
CREATE INDEX idx_comments_user_id ON comments(user_id);
CREATE INDEX idx_comments_parent_id ON comments(parent_id);
CREATE INDEX idx_comments_created_at ON comments(created_at DESC);

-- ê°ì •í‰ê°€ (Reactions)
CREATE TABLE reactions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    target_type VARCHAR(50) NOT NULL, -- review, comment, post
    target_id INTEGER NOT NULL,
    reaction_type VARCHAR(50) NOT NULL, -- like, love, helpful, funny, angry, sad
    
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(user_id, target_type, target_id, reaction_type)
);

CREATE INDEX idx_reactions_target ON reactions(target_type, target_id);
CREATE INDEX idx_reactions_user_id ON reactions(user_id);
CREATE INDEX idx_reactions_type ON reactions(reaction_type);

-- ë¦¬ë·° ë„ì›€ë¨ íˆ¬í‘œ
CREATE TABLE review_helpfulness (
    review_id INTEGER REFERENCES reviews(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    is_helpful BOOLEAN NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (review_id, user_id)
);

-- ê²Œì‹œê¸€ (CMS)
CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    category_id INTEGER REFERENCES post_categories(id),
    
    title VARCHAR(500) NOT NULL,
    slug VARCHAR(500) UNIQUE,
    content TEXT NOT NULL,
    excerpt TEXT, -- ìš”ì•½
    
    -- ë¯¸ë””ì–´
    featured_image VARCHAR(500),
    images JSONB,
    videos JSONB,
    attachments JSONB, -- ì²¨ë¶€íŒŒì¼
    
    -- SEO
    meta_title VARCHAR(200),
    meta_description TEXT,
    meta_keywords JSONB,
    
    -- í†µê³„
    view_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    share_count INTEGER DEFAULT 0,
    
    -- ìƒíƒœ
    status VARCHAR(20) DEFAULT 'draft', -- draft, published, scheduled, archived
    visibility VARCHAR(20) DEFAULT 'public', -- public, private, members_only
    is_featured BOOLEAN DEFAULT FALSE,
    is_pinned BOOLEAN DEFAULT FALSE,
    
    -- ìŠ¤ì¼€ì¤„ë§
    published_at TIMESTAMP,
    scheduled_at TIMESTAMP,
    
    -- ì‘ì„±ì ì •ë³´
    author_name VARCHAR(200),
    author_avatar VARCHAR(500),
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deleted_at TIMESTAMP
);

CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_category_id ON posts(category_id);
CREATE INDEX idx_posts_slug ON posts(slug);
CREATE INDEX idx_posts_status ON posts(status);
CREATE INDEX idx_posts_published_at ON posts(published_at DESC);

-- ê²Œì‹œê¸€ ì¹´í…Œê³ ë¦¬
CREATE TABLE post_categories (
    id SERIAL PRIMARY KEY,
    parent_id INTEGER REFERENCES post_categories(id),
    name_ko VARCHAR(200),
    name_en VARCHAR(200),
    slug VARCHAR(200) UNIQUE,
    description TEXT,
    icon VARCHAR(100),
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- ë¯¸ë””ì–´ ë¼ì´ë¸ŒëŸ¬ë¦¬
CREATE TABLE media (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    
    -- íŒŒì¼ ì •ë³´
    filename VARCHAR(500) NOT NULL,
    original_filename VARCHAR(500),
    file_path VARCHAR(1000) NOT NULL,
    file_url VARCHAR(1000) NOT NULL,
    file_size BIGINT, -- bytes
    mime_type VARCHAR(100),
    
    -- ë¯¸ë””ì–´ íƒ€ì…
    media_type VARCHAR(50), -- image, video, audio, document
    
    -- ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„°
    width INTEGER,
    height INTEGER,
    thumbnail_url VARCHAR(1000),
    
    -- ë¹„ë””ì˜¤ ë©”íƒ€ë°ì´í„°
    duration INTEGER, -- seconds
    
    -- íƒœê·¸ ë° ì„¤ëª…
    title VARCHAR(500),
    alt_text VARCHAR(500),
    caption TEXT,
    description TEXT,
    tags JSONB,
    
    -- ì‚¬ìš© ì¶”ì 
    usage_count INTEGER DEFAULT 0,
    used_in JSONB, -- [{type: 'review', id: 123}, {type: 'post', id: 456}]
    
    -- CDN
    cdn_url VARCHAR(1000),
    is_optimized BOOLEAN DEFAULT FALSE,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_media_user_id ON media(user_id);
CREATE INDEX idx_media_type ON media(media_type);
CREATE INDEX idx_media_created_at ON media(created_at DESC);

-- ë¦¬ë·°-ê±°ë˜ ë§¤í•‘
CREATE TABLE review_transaction_mapping (
    review_id INTEGER REFERENCES reviews(id) ON DELETE CASCADE,
    transaction_id INTEGER REFERENCES transactions(id) ON DELETE CASCADE,
    payment_id INTEGER REFERENCES payments(id),
    order_id INTEGER REFERENCES orders(id),
    blockchain_tx_hash VARCHAR(255),
    verified_at TIMESTAMP,
    PRIMARY KEY (review_id, transaction_id)
);

-- ë¦¬ë·°-ë¦¬ì›Œë“œ ë§¤í•‘
CREATE TABLE review_reward_mapping (
    review_id INTEGER REFERENCES reviews(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id),
    points_earned INTEGER,
    reward_type VARCHAR(50), -- review_text, review_photo, review_video, best_review
    transaction_id INTEGER REFERENCES point_transactions(id),
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (review_id)
);
```

---

## 3. Backend API ì„¤ê³„

### 3.1 ë¦¬ë·° API

```python
# reviews_api.py
from fastapi import APIRouter, UploadFile, File
from typing import List, Optional

router = APIRouter()

class ReviewCreate(BaseModel):
    product_id: int
    order_id: Optional[int]
    rating_overall: int = Field(..., ge=1, le=5)
    rating_quality: Optional[int] = Field(None, ge=1, le=5)
    rating_delivery: Optional[int] = Field(None, ge=1, le=5)
    rating_packaging: Optional[int] = Field(None, ge=1, le=5)
    title: str = Field(..., max_length=200)
    content: str = Field(..., min_length=10)
    pros: Optional[str]
    cons: Optional[str]
    images: Optional[List[str]] = []
    videos: Optional[List[str]] = []

class ReviewResponse(BaseModel):
    id: int
    product_id: int
    user: UserBasic
    rating_overall: int
    title: str
    content: str
    images: List[dict]
    is_verified_purchase: bool
    helpful_count: int
    unhelpful_count: int
    comment_count: int
    created_at: datetime
    blockchain_hash: Optional[str]

@router.post("/reviews")
async def create_review(
    review: ReviewCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ë¦¬ë·° ì‘ì„±"""
    
    # 1. êµ¬ë§¤ ê²€ì¦
    order = await verify_purchase(db, current_user.id, review.order_id)
    if not order:
        raise HTTPException(
            status_code=400,
            detail="Only verified purchases can leave reviews"
        )
    
    # 2. ì¤‘ë³µ ë¦¬ë·° í™•ì¸
    existing = await db.fetch_one(
        "SELECT id FROM reviews WHERE user_id = $1 AND product_id = $2 AND order_id = $3",
        current_user.id, review.product_id, review.order_id
    )
    if existing:
        raise HTTPException(status_code=400, detail="Review already exists")
    
    # 3. ë¦¬ë·° ì €ì¥
    review_id = await db.fetch_val(
        """
        INSERT INTO reviews (
            product_id, user_id, order_id, rating_overall, rating_quality,
            rating_delivery, rating_packaging, title, content, pros, cons,
            images, videos, is_verified_purchase
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, TRUE)
        RETURNING id
        """,
        review.product_id, current_user.id, review.order_id,
        review.rating_overall, review.rating_quality, review.rating_delivery,
        review.rating_packaging, review.title, review.content,
        review.pros, review.cons,
        json.dumps(review.images), json.dumps(review.videos)
    )
    
    # 4. ê±°ë˜-ê²°ì œ ë§¤í•‘
    transaction = await get_transaction_by_order(db, review.order_id)
    if transaction:
        await db.execute(
            """
            INSERT INTO review_transaction_mapping (
                review_id, transaction_id, payment_id, order_id
            ) VALUES ($1, $2, $3, $4)
            """,
            review_id, transaction.id, transaction.payment_id, review.order_id
        )
    
    # 5. ë¸”ë¡ì²´ì¸ ê¸°ë¡ (ë¦¬ë·° ìœ„ë³€ì¡° ë°©ì§€)
    blockchain_hash = await record_review_on_blockchain(
        review_id, current_user.id, review.product_id
    )
    await db.execute(
        "UPDATE reviews SET blockchain_hash = $1, blockchain_verified = TRUE WHERE id = $2",
        blockchain_hash, review_id
    )
    
    # 6. ë¦¬ì›Œë“œ í¬ì¸íŠ¸ ì§€ê¸‰
    points = calculate_review_points(review)
    await grant_review_reward(db, current_user.id, review_id, points)
    
    # 7. ìƒí’ˆ í‰ì  ì—…ë°ì´íŠ¸
    await update_product_rating(db, review.product_id)
    
    # 8. ì•Œë¦¼ ë°œì†¡ (íŒë§¤ìì—ê²Œ)
    await send_notification(
        user_id=order.seller_id,
        type='new_review',
        data={'review_id': review_id, 'product_id': review.product_id}
    )
    
    return {"id": review_id, "message": "Review created successfully"}

@router.get("/reviews/{review_id}")
async def get_review(review_id: int, db: Session = Depends(get_db)):
    """ë¦¬ë·° ìƒì„¸ ì¡°íšŒ"""
    review = await db.fetch_one(
        """
        SELECT r.*, u.username, u.avatar_url, u.full_name,
               (SELECT COUNT(*) FROM comments WHERE target_type='review' AND target_id=r.id) as comment_count
        FROM reviews r
        JOIN users u ON r.user_id = u.id
        WHERE r.id = $1 AND r.status = 'published'
        """,
        review_id
    )
    
    if not review:
        raise HTTPException(status_code=404, detail="Review not found")
    
    # ì¡°íšŒìˆ˜ ì¦ê°€
    await db.execute("UPDATE reviews SET view_count = view_count + 1 WHERE id = $1", review_id)
    
    return ReviewResponse(**review)

@router.post("/reviews/{review_id}/helpful")
async def mark_helpful(
    review_id: int,
    is_helpful: bool,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ë¦¬ë·° ë„ì›€ë¨ í‘œì‹œ"""
    await db.execute(
        """
        INSERT INTO review_helpfulness (review_id, user_id, is_helpful)
        VALUES ($1, $2, $3)
        ON CONFLICT (review_id, user_id) DO UPDATE
        SET is_helpful = EXCLUDED.is_helpful
        """,
        review_id, current_user.id, is_helpful
    )
    
    # ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
    await db.execute(
        """
        UPDATE reviews
        SET helpful_count = (SELECT COUNT(*) FROM review_helpfulness WHERE review_id = $1 AND is_helpful = TRUE),
            unhelpful_count = (SELECT COUNT(*) FROM review_helpfulness WHERE review_id = $1 AND is_helpful = FALSE)
        WHERE id = $1
        """,
        review_id
    )
    
    return {"message": "Vote recorded"}

def calculate_review_points(review: ReviewCreate) -> int:
    """ë¦¬ë·° í¬ì¸íŠ¸ ê³„ì‚°"""
    points = 100  # ê¸°ë³¸ í¬ì¸íŠ¸
    
    if review.images and len(review.images) > 0:
        points += 50  # ì‚¬ì§„ ë¦¬ë·°
    
    if review.videos and len(review.videos) > 0:
        points += 100  # ë™ì˜ìƒ ë¦¬ë·°
    
    if len(review.content) > 100:
        points += 30  # ìƒì„¸ ë¦¬ë·°
    
    if review.pros or review.cons:
        points += 20  # ì¥ë‹¨ì  ì‘ì„±
    
    return points

async def grant_review_reward(
    db: Session,
    user_id: int,
    review_id: int,
    points: int
):
    """ë¦¬ë·° ë¦¬ì›Œë“œ ì§€ê¸‰"""
    # í¬ì¸íŠ¸ íŠ¸ëœì­ì…˜ ìƒì„±
    tx_id = await db.fetch_val(
        """
        INSERT INTO point_transactions (user_id, type, amount, reason, reference_type, reference_id)
        VALUES ($1, 'earn', $2, 'Review reward', 'review', $3)
        RETURNING id
        """,
        user_id, points, review_id
    )
    
    # ë§¤í•‘ í…Œì´ë¸” ì—…ë°ì´íŠ¸
    await db.execute(
        """
        INSERT INTO review_reward_mapping (review_id, user_id, points_earned, reward_type, transaction_id)
        VALUES ($1, $2, $3, $4, $5)
        """,
        review_id, user_id, points, 'review_text', tx_id
    )
    
    # ì‚¬ìš©ì í¬ì¸íŠ¸ ì—…ë°ì´íŠ¸
    await db.execute(
        "UPDATE reward_points SET points = points + $1, total_earned = total_earned + $1 WHERE user_id = $2",
        points, user_id
    )
```

### 3.2 ëŒ“ê¸€ API

```python
# comments_api.py
class CommentCreate(BaseModel):
    target_type: str  # review, post, product
    target_id: int
    parent_id: Optional[int] = None
    content: str = Field(..., min_length=1, max_length=1000)
    images: Optional[List[str]] = []

class CommentResponse(BaseModel):
    id: int
    user: UserBasic
    content: str
    images: List[str]
    like_count: int
    dislike_count: int
    replies: List['CommentResponse'] = []
    is_author_reply: bool
    created_at: datetime

@router.post("/comments")
async def create_comment(
    comment: CommentCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ëŒ“ê¸€ ì‘ì„±"""
    
    # 1. ëŒ€ìƒ ì¡´ì¬ í™•ì¸
    target_exists = await verify_target_exists(
        db, comment.target_type, comment.target_id
    )
    if not target_exists:
        raise HTTPException(status_code=404, detail="Target not found")
    
    # 2. ëŒ“ê¸€ ì €ì¥
    comment_id = await db.fetch_val(
        """
        INSERT INTO comments (target_type, target_id, parent_id, user_id, content, images)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
        """,
        comment.target_type, comment.target_id, comment.parent_id,
        current_user.id, comment.content, json.dumps(comment.images)
    )
    
    # 3. ì‘ì„±ì ë‹µê¸€ ì—¬ë¶€ í™•ì¸
    if comment.target_type == 'review':
        review = await db.fetch_one(
            "SELECT user_id FROM reviews WHERE id = $1",
            comment.target_id
        )
        if review and review['user_id'] == current_user.id:
            await db.execute(
                "UPDATE comments SET is_author_reply = TRUE WHERE id = $1",
                comment_id
            )
    
    # 4. ë¸”ë¡ì²´ì¸ ê¸°ë¡
    blockchain_hash = await record_comment_on_blockchain(
        comment_id, current_user.id, comment.target_type, comment.target_id
    )
    await db.execute(
        "UPDATE comments SET blockchain_hash = $1 WHERE id = $2",
        blockchain_hash, comment_id
    )
    
    # 5. ëŒ“ê¸€ ìˆ˜ ì—…ë°ì´íŠ¸
    await update_comment_count(db, comment.target_type, comment.target_id)
    
    # 6. ì•Œë¦¼ ë°œì†¡
    await notify_comment_created(
        db, comment.target_type, comment.target_id, current_user.id
    )
    
    return {"id": comment_id, "message": "Comment created"}

@router.get("/comments")
async def get_comments(
    target_type: str,
    target_id: int,
    page: int = 1,
    limit: int = 20,
    sort: str = 'recent',  # recent, popular
    db: Session = Depends(get_db)
):
    """ëŒ“ê¸€ ëª©ë¡ ì¡°íšŒ"""
    offset = (page - 1) * limit
    
    order_by = "created_at DESC" if sort == 'recent' else "like_count DESC"
    
    comments = await db.fetch_all(
        f"""
        SELECT c.*, u.username, u.avatar_url, u.full_name,
               (SELECT COUNT(*) FROM comments WHERE parent_id = c.id) as reply_count
        FROM comments c
        JOIN users u ON c.user_id = u.id
        WHERE c.target_type = $1 AND c.target_id = $2 AND c.parent_id IS NULL
        AND c.status = 'published' AND c.deleted_at IS NULL
        ORDER BY {order_by}
        LIMIT $3 OFFSET $4
        """,
        target_type, target_id, limit, offset
    )
    
    # ëŒ€ëŒ“ê¸€ ê°€ì ¸ì˜¤ê¸°
    result = []
    for comment in comments:
        replies = await get_comment_replies(db, comment['id'])
        result.append({
            **comment,
            'replies': replies
        })
    
    return result

async def get_comment_replies(db: Session, parent_id: int) -> List[dict]:
    """ëŒ€ëŒ“ê¸€ ì¡°íšŒ"""
    return await db.fetch_all(
        """
        SELECT c.*, u.username, u.avatar_url, u.full_name
        FROM comments c
        JOIN users u ON c.user_id = u.id
        WHERE c.parent_id = $1 AND c.status = 'published' AND c.deleted_at IS NULL
        ORDER BY c.created_at ASC
        """,
        parent_id
    )
```

### 3.3 ê°ì •í‰ê°€ API

```python
# reactions_api.py
class ReactionCreate(BaseModel):
    target_type: str  # review, comment, post
    target_id: int
    reaction_type: str  # like, love, helpful, funny, angry, sad

@router.post("/reactions")
async def add_reaction(
    reaction: ReactionCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ê°ì •í‰ê°€ ì¶”ê°€"""
    
    # ê¸°ì¡´ ë°˜ì‘ í™•ì¸ ë° í† ê¸€
    existing = await db.fetch_one(
        """
        SELECT id FROM reactions
        WHERE user_id = $1 AND target_type = $2 AND target_id = $3 AND reaction_type = $4
        """,
        current_user.id, reaction.target_type, reaction.target_id, reaction.reaction_type
    )
    
    if existing:
        # ì´ë¯¸ ê°™ì€ ë°˜ì‘ì´ ìˆìœ¼ë©´ ì œê±° (í† ê¸€)
        await db.execute(
            "DELETE FROM reactions WHERE id = $1",
            existing['id']
        )
        action = "removed"
    else:
        # ë‹¤ë¥¸ íƒ€ì…ì˜ ë°˜ì‘ ì œê±° (í•œ ë²ˆì— í•˜ë‚˜ì˜ ë°˜ì‘ë§Œ)
        await db.execute(
            """
            DELETE FROM reactions
            WHERE user_id = $1 AND target_type = $2 AND target_id = $3
            """,
            current_user.id, reaction.target_type, reaction.target_id
        )
        
        # ìƒˆ ë°˜ì‘ ì¶”ê°€
        await db.execute(
            """
            INSERT INTO reactions (user_id, target_type, target_id, reaction_type)
            VALUES ($1, $2, $3, $4)
            """,
            current_user.id, reaction.target_type, reaction.target_id, reaction.reaction_type
        )
        action = "added"
    
    # ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
    await update_reaction_counts(db, reaction.target_type, reaction.target_id)
    
    return {"message": f"Reaction {action}"}

@router.get("/reactions")
async def get_reactions(
    target_type: str,
    target_id: int,
    db: Session = Depends(get_db)
):
    """ê°ì •í‰ê°€ í†µê³„ ì¡°íšŒ"""
    reactions = await db.fetch_all(
        """
        SELECT reaction_type, COUNT(*) as count
        FROM reactions
        WHERE target_type = $1 AND target_id = $2
        GROUP BY reaction_type
        """,
        target_type, target_id
    )
    
    return {row['reaction_type']: row['count'] for row in reactions}

async def update_reaction_counts(db: Session, target_type: str, target_id: int):
    """ë°˜ì‘ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸"""
    if target_type == 'comment':
        like_count = await db.fetch_val(
            """
            SELECT COUNT(*) FROM reactions
            WHERE target_type = 'comment' AND target_id = $1 AND reaction_type = 'like'
            """,
            target_id
        )
        await db.execute(
            "UPDATE comments SET like_count = $1 WHERE id = $2",
            like_count, target_id
        )
```

### 3.4 ê²Œì‹œê¸€ CMS API

```python
# posts_api.py
class PostCreate(BaseModel):
    title: str = Field(..., max_length=500)
    content: str = Field(..., min_length=10)
    category_id: Optional[int]
    excerpt: Optional[str]
    featured_image: Optional[str]
    images: Optional[List[str]] = []
    status: str = 'draft'  # draft, published
    visibility: str = 'public'
    scheduled_at: Optional[datetime]
    meta_title: Optional[str]
    meta_description: Optional[str]
    meta_keywords: Optional[List[str]]

@router.post("/posts")
async def create_post(
    post: PostCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ê²Œì‹œê¸€ ì‘ì„±"""
    
    # slug ìƒì„±
    slug = generate_slug(post.title)
    
    post_id = await db.fetch_val(
        """
        INSERT INTO posts (
            user_id, category_id, title, slug, content, excerpt,
            featured_image, images, status, visibility, scheduled_at,
            meta_title, meta_description, meta_keywords,
            published_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
        RETURNING id
        """,
        current_user.id, post.category_id, post.title, slug, post.content,
        post.excerpt, post.featured_image, json.dumps(post.images),
        post.status, post.visibility, post.scheduled_at,
        post.meta_title, post.meta_description, json.dumps(post.meta_keywords),
        datetime.now() if post.status == 'published' else None
    )
    
    return {"id": post_id, "slug": slug}

@router.post("/posts/{post_id}/publish")
async def publish_post(
    post_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ê²Œì‹œê¸€ ë°œí–‰"""
    await db.execute(
        """
        UPDATE posts
        SET status = 'published', published_at = NOW(), updated_at = NOW()
        WHERE id = $1 AND user_id = $2
        """,
        post_id, current_user.id
    )
    
    return {"message": "Post published"}
```

### 3.5 ë¯¸ë””ì–´ ì—…ë¡œë“œ API

```python
# media_api.py
import aiofiles
from PIL import Image
import io

@router.post("/media/upload")
async def upload_media(
    file: UploadFile = File(...),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ë¯¸ë””ì–´ ì—…ë¡œë“œ"""
    
    # 1. íŒŒì¼ ê²€ì¦
    if file.size > 10 * 1024 * 1024:  # 10MB ì œí•œ
        raise HTTPException(status_code=400, detail="File too large")
    
    allowed_types = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4']
    if file.content_type not in allowed_types:
        raise HTTPException(status_code=400, detail="Invalid file type")
    
    # 2. íŒŒì¼ëª… ìƒì„±
    ext = file.filename.split('.')[-1]
    filename = f"{uuid.uuid4()}.{ext}"
    file_path = f"uploads/{datetime.now().year}/{datetime.now().month}/{filename}"
    
    # 3. S3 ì—…ë¡œë“œ
    file_url = await upload_to_s3(file, file_path)
    
    # 4. ì´ë¯¸ì§€ ì²˜ë¦¬ (ì¸ë„¤ì¼ ìƒì„±)
    thumbnail_url = None
    width, height = None, None
    
    if file.content_type.startswith('image/'):
        # ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
        content = await file.read()
        image = Image.open(io.BytesIO(content))
        width, height = image.size
        
        # ì¸ë„¤ì¼ ìƒì„±
        thumbnail = create_thumbnail(image, (300, 300))
        thumbnail_path = f"thumbnails/{filename}"
        thumbnail_url = await upload_thumbnail_to_s3(thumbnail, thumbnail_path)
    
    # 5. DB ì €ì¥
    media_id = await db.fetch_val(
        """
        INSERT INTO media (
            user_id, filename, original_filename, file_path, file_url,
            file_size, mime_type, media_type, width, height, thumbnail_url
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        RETURNING id
        """,
        current_user.id, filename, file.filename, file_path, file_url,
        file.size, file.content_type,
        'image' if file.content_type.startswith('image/') else 'video',
        width, height, thumbnail_url
    )
    
    return {
        "id": media_id,
        "url": file_url,
        "thumbnail_url": thumbnail_url,
        "width": width,
        "height": height
    }

@router.post("/media/edit")
async def edit_image(
    media_id: int,
    operations: List[dict],  # [{type: 'crop', params: {...}}, {type: 'filter', params: {...}}]
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ì´ë¯¸ì§€ í¸ì§‘"""
    
    # ë¯¸ë””ì–´ ì¡°íšŒ
    media = await db.fetch_one(
        "SELECT * FROM media WHERE id = $1 AND user_id = $2",
        media_id, current_user.id
    )
    
    if not media:
        raise HTTPException(status_code=404, detail="Media not found")
    
    # ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ
    image_data = await download_from_s3(media['file_path'])
    image = Image.open(io.BytesIO(image_data))
    
    # í¸ì§‘ ì‘ì—… ìˆ˜í–‰
    for op in operations:
        if op['type'] == 'crop':
            image = image.crop(tuple(op['params']['box']))
        elif op['type'] == 'resize':
            image = image.resize(tuple(op['params']['size']))
        elif op['type'] == 'rotate':
            image = image.rotate(op['params']['degrees'])
        elif op['type'] == 'filter':
            # í•„í„° ì ìš© (PIL ImageFilter)
            pass
    
    # í¸ì§‘ëœ ì´ë¯¸ì§€ ì—…ë¡œë“œ
    edited_filename = f"edited_{media['filename']}"
    edited_path = f"uploads/edited/{edited_filename}"
    edited_url = await upload_pil_image_to_s3(image, edited_path)
    
    # ìƒˆ ë¯¸ë””ì–´ í•­ëª© ìƒì„±
    new_media_id = await db.fetch_val(
        """
        INSERT INTO media (
            user_id, filename, file_path, file_url, mime_type, media_type, width, height
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING id
        """,
        current_user.id, edited_filename, edited_path, edited_url,
        'image/jpeg', 'image', image.width, image.height
    )
    
    return {
        "id": new_media_id,
        "url": edited_url
    }
```

---

## 4. Frontend ì»´í¬ë„ŒíŠ¸

### 4.1 ë¦¬ë·° ì‘ì„± ì»´í¬ë„ŒíŠ¸

```tsx
// ReviewForm.tsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { Rating, ImageUpload, TextEditor } from '@/components';

interface ReviewFormProps {
  productId: number;
  orderId: number;
  onSuccess: () => void;
}

export const ReviewForm: React.FC<ReviewFormProps> = ({
  productId,
  orderId,
  onSuccess
}) => {
  const { register, handleSubmit, setValue, watch } = useForm();
  const [images, setImages] = useState<string[]>([]);
  const [videos, setVideos] = useState<string[]>([]);
  
  const onSubmit = async (data: any) => {
    const response = await api.post('/reviews', {
      product_id: productId,
      order_id: orderId,
      ...data,
      images,
      videos
    });
    
    if (response.ok) {
      onSuccess();
      toast.success('ë¦¬ë·°ê°€ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. í¬ì¸íŠ¸ê°€ ì ë¦½ë˜ì—ˆìŠµë‹ˆë‹¤!');
    }
  };
  
  return (
    <ReviewFormContainer onSubmit={handleSubmit(onSubmit)}>
      <FormSection>
        <h3>ìƒí’ˆì€ ì–´ë– ì…¨ë‚˜ìš”?</h3>
        
        {/* ì „ì²´ í‰ì  */}
        <RatingRow>
          <label>ì „ì²´ í‰ì </label>
          <Rating
            value={watch('rating_overall')}
            onChange={(val) => setValue('rating_overall', val)}
            size="large"
          />
        </RatingRow>
        
        {/* ì„¸ë¶€ í‰ì  */}
        <RatingRow>
          <label>ìƒí’ˆ í’ˆì§ˆ</label>
          <Rating
            value={watch('rating_quality')}
            onChange={(val) => setValue('rating_quality', val)}
          />
        </RatingRow>
        
        <RatingRow>
          <label>ë°°ì†¡ ì†ë„</label>
          <Rating
            value={watch('rating_delivery')}
            onChange={(val) => setValue('rating_delivery', val)}
          />
        </RatingRow>
        
        <RatingRow>
          <label>í¬ì¥ ìƒíƒœ</label>
          <Rating
            value={watch('rating_packaging')}
            onChange={(val) => setValue('rating_packaging', val)}
          />
        </RatingRow>
      </FormSection>
      
      <FormSection>
        <h3>ë¦¬ë·° ì‘ì„±</h3>
        
        <Input
          {...register('title', { required: true })}
          placeholder="ë¦¬ë·° ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
          maxLength={200}
        />
        
        <TextArea
          {...register('content', { required: true, minLength: 10 })}
          placeholder="ìƒí’ˆì— ëŒ€í•œ ì†”ì§í•œ ë¦¬ë·°ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš” (ìµœì†Œ 10ì)"
          rows={5}
        />
        
        <TwoColumnGrid>
          <TextArea
            {...register('pros')}
            placeholder="ì¥ì "
            rows={3}
          />
          <TextArea
            {...register('cons')}
            placeholder="ë‹¨ì "
            rows={3}
          />
        </TwoColumnGrid>
      </FormSection>
      
      <FormSection>
        <h3>ì‚¬ì§„ ë° ë™ì˜ìƒ ì²¨ë¶€</h3>
        <RewardBadge>ì‚¬ì§„ +50P, ë™ì˜ìƒ +100P</RewardBadge>
        
        <ImageUpload
          multiple
          maxFiles={10}
          onUpload={(urls) => setImages([...images, ...urls])}
          onRemove={(url) => setImages(images.filter(img => img !== url))}
          value={images}
        />
        
        <VideoUpload
          maxFiles={3}
          onUpload={(urls) => setVideos([...videos, ...urls])}
          value={videos}
        />
      </FormSection>
      
      <SubmitSection>
        <RewardInfo>
          ì˜ˆìƒ ì ë¦½ í¬ì¸íŠ¸: {calculatePoints()}P
        </RewardInfo>
        <Button type="submit" size="large">ë¦¬ë·° ë“±ë¡</Button>
      </SubmitSection>
    </ReviewFormContainer>
  );
};
```

### 4.2 ëŒ“ê¸€ ì‹œìŠ¤í…œ ì»´í¬ë„ŒíŠ¸

```tsx
// CommentSection.tsx
export const CommentSection: React.FC<CommentSectionProps> = ({
  targetType,
  targetId
}) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState('');
  const [replyingTo, setReplyingTo] = useState<number | null>(null);
  
  const handleSubmit = async () => {
    const response = await api.post('/comments', {
      target_type: targetType,
      target_id: targetId,
      parent_id: replyingTo,
      content: newComment
    });
    
    if (response.ok) {
      setComments([response.data, ...comments]);
      setNewComment('');
      setReplyingTo(null);
    }
  };
  
  return (
    <CommentContainer>
      <CommentHeader>
        <h3>ëŒ“ê¸€ {comments.length}</h3>
      </CommentHeader>
      
      {/* ëŒ“ê¸€ ì‘ì„± */}
      <CommentInput>
        <Avatar src={currentUser.avatar} />
        <TextArea
          value={newComment}
          onChange={(e) => setNewComment(e.target.value)}
          placeholder="ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”..."
          rows={3}
        />
        <Button onClick={handleSubmit}>ë“±ë¡</Button>
      </CommentInput>
      
      {/* ëŒ“ê¸€ ëª©ë¡ */}
      <CommentList>
        {comments.map(comment => (
          <CommentItem key={comment.id}>
            <CommentAuthor>
              <Avatar src={comment.user.avatar} size="small" />
              <AuthorName>{comment.user.name}</AuthorName>
              <CommentDate>{formatRelativeTime(comment.created_at)}</CommentDate>
            </CommentAuthor>
            
            <CommentContent>{comment.content}</CommentContent>
            
            {comment.images && comment.images.length > 0 && (
              <CommentImages>
                {comment.images.map(img => (
                  <img key={img} src={img} alt="" />
                ))}
              </CommentImages>
            )}
            
            <CommentActions>
              <ActionButton onClick={() => handleReaction(comment.id, 'like')}>
                <ThumbsUpIcon /> {comment.like_count}
              </ActionButton>
              <ActionButton onClick={() => setReplyingTo(comment.id)}>
                <ReplyIcon /> ë‹µê¸€
              </ActionButton>
              {comment.user.id === currentUser.id && (
                <>
                  <ActionButton onClick={() => handleEdit(comment.id)}>
                    ìˆ˜ì •
                  </ActionButton>
                  <ActionButton onClick={() => handleDelete(comment.id)}>
                    ì‚­ì œ
                  </ActionButton>
                </>
              )}
            </CommentActions>
            
            {/* ëŒ€ëŒ“ê¸€ */}
            {comment.replies && comment.replies.length > 0 && (
              <RepliesList>
                {comment.replies.map(reply => (
                  <ReplyItem key={reply.id}>
                    {/* ëŒ€ëŒ“ê¸€ ë Œë”ë§ */}
                  </ReplyItem>
                ))}
              </RepliesList>
            )}
          </CommentItem>
        ))}
      </CommentList>
    </CommentContainer>
  );
};
```

### 4.3 ê°ì •í‰ê°€ ì»´í¬ë„ŒíŠ¸

```tsx
// ReactionButtons.tsx
export const ReactionButtons: React.FC<ReactionButtonsProps> = ({
  targetType,
  targetId
}) => {
  const [reactions, setReactions] = useState<Record<string, number>>({});
  const [userReaction, setUserReaction] = useState<string | null>(null);
  
  const reactionTypes = [
    { type: 'like', icon: 'ğŸ‘', label: 'ì¢‹ì•„ìš”' },
    { type: 'love', icon: 'â¤ï¸', label: 'ìµœê³ ì˜ˆìš”' },
    { type: 'helpful', icon: 'ğŸ’¡', label: 'ë„ì›€ë¨' },
    { type: 'funny', icon: 'ğŸ˜„', label: 'ì¬ë¯¸ìˆì–´ìš”' }
  ];
  
  const handleReaction = async (reactionType: string) => {
    await api.post('/reactions', {
      target_type: targetType,
      target_id: targetId,
      reaction_type: reactionType
    });
    
    // ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
    if (userReaction === reactionType) {
      setUserReaction(null);
      setReactions({
        ...reactions,
        [reactionType]: (reactions[reactionType] || 0) - 1
      });
    } else {
      if (userReaction) {
        setReactions({
          ...reactions,
          [userReaction]: (reactions[userReaction] || 0) - 1,
          [reactionType]: (reactions[reactionType] || 0) + 1
        });
      } else {
        setReactions({
          ...reactions,
          [reactionType]: (reactions[reactionType] || 0) + 1
        });
      }
      setUserReaction(reactionType);
    }
  };
  
  return (
    <ReactionButtonsContainer>
      {reactionTypes.map(({ type, icon, label }) => (
        <ReactionButton
          key={type}
          active={userReaction === type}
          onClick={() => handleReaction(type)}
        >
          <span className="icon">{icon}</span>
          <span className="label">{label}</span>
          <span className="count">{reactions[type] || 0}</span>
        </ReactionButton>
      ))}
    </ReactionButtonsContainer>
  );
};
```

### 4.4 ì´ë¯¸ì§€ í¸ì§‘ê¸° ì»´í¬ë„ŒíŠ¸

```tsx
// ImageEditor.tsx
import Cropper from 'react-easy-crop';

export const ImageEditor: React.FC<ImageEditorProps> = ({
  image,
  onSave
}) => {
  const [crop, setCrop] = useState({ x: 0, y: 0 });
  const [zoom, setZoom] = useState(1);
  const [rotation, setRotation] = useState(0);
  const [filter, setFilter] = useState('none');
  
  const filters = [
    { name: 'none', label: 'ì›ë³¸' },
    { name: 'grayscale', label: 'í‘ë°±' },
    { name: 'sepia', label: 'ì„¸í”¼ì•„' },
    { name: 'brightness', label: 'ë°ê²Œ' },
    { name: 'contrast', label: 'ëŒ€ë¹„' }
  ];
  
  const handleSave = async () => {
    const operations = [
      { type: 'crop', params: { box: croppedAreaPixels } },
      { type: 'rotate', params: { degrees: rotation } },
      { type: 'filter', params: { name: filter } }
    ];
    
    const result = await api.post('/media/edit', {
      media_id: image.id,
      operations
    });
    
    onSave(result.data.url);
  };
  
  return (
    <EditorContainer>
      <EditorCanvas>
        <Cropper
          image={image.url}
          crop={crop}
          zoom={zoom}
          rotation={rotation}
          onCropChange={setCrop}
          onZoomChange={setZoom}
          onRotationChange={setRotation}
          aspect={4 / 3}
        />
      </EditorCanvas>
      
      <EditorControls>
        <ControlGroup>
          <label>í™•ëŒ€/ì¶•ì†Œ</label>
          <Slider
            value={zoom}
            onChange={setZoom}
            min={1}
            max={3}
            step={0.1}
          />
        </ControlGroup>
        
        <ControlGroup>
          <label>íšŒì „</label>
          <Slider
            value={rotation}
            onChange={setRotation}
            min={0}
            max={360}
            step={1}
          />
        </ControlGroup>
        
        <ControlGroup>
          <label>í•„í„°</label>
          <FilterGrid>
            {filters.map(f => (
              <FilterButton
                key={f.name}
                active={filter === f.name}
                onClick={() => setFilter(f.name)}
              >
                {f.label}
              </FilterButton>
            ))}
          </FilterGrid>
        </ControlGroup>
        
        <ButtonGroup>
          <Button variant="secondary" onClick={onCancel}>ì·¨ì†Œ</Button>
          <Button onClick={handleSave}>ì €ì¥</Button>
        </ButtonGroup>
      </EditorControls>
    </EditorContainer>
  );
};
```

---

## 5. ë°ì´í„° ë§¤í•‘ ë° ì—°ê³„

### 5.1 ë¦¬ë·°-ê±°ë˜-ê²°ì œ ì—°ê³„ í”Œë¡œìš°

```
1. ê³ ê°ì´ ìƒí’ˆ êµ¬ë§¤
   â†“
2. ê²°ì œ ì™„ë£Œ (payments í…Œì´ë¸”)
   â†“
3. ê±°ë˜ ìƒì„± (transactions í…Œì´ë¸”)
   â†“
4. ë¸”ë¡ì²´ì¸ì— ê±°ë˜ ê¸°ë¡ (blockchain_transactions í…Œì´ë¸”)
   â†“
5. ìƒí’ˆ ë°°ì†¡ ì™„ë£Œ
   â†“
6. ë¦¬ë·° ì‘ì„± ê°€ëŠ¥ ì•Œë¦¼
   â†“
7. ë¦¬ë·° ì‘ì„± (reviews í…Œì´ë¸”)
   â†“
8. ë¦¬ë·°-ê±°ë˜ ë§¤í•‘ (review_transaction_mapping)
   â†“
9. ë¦¬ë·° ë¸”ë¡ì²´ì¸ ê¸°ë¡ (ìœ„ë³€ì¡° ë°©ì§€)
   â†“
10. ë¦¬ì›Œë“œ í¬ì¸íŠ¸ ì§€ê¸‰ (point_transactions)
    â†“
11. ë¦¬ë·°-ë¦¬ì›Œë“œ ë§¤í•‘ (review_reward_mapping)
```

### 5.2 í‰ê°€-ë¼ë²¨ë§ ì—°ê³„

```python
# labeling_integration.py
async def create_review_labels_for_ai(review_id: int, db: Session):
    """ë¦¬ë·° ë°ì´í„°ë¥¼ AI í•™ìŠµìš©ìœ¼ë¡œ ë¼ë²¨ë§"""
    
    review = await db.fetch_one(
        "SELECT * FROM reviews WHERE id = $1",
        review_id
    )
    
    # ìë™ ë¼ë²¨ë§
    labels = []
    
    # ê°ì • ë¶„ì„
    sentiment = analyze_sentiment(review['content'])
    labels.append({
        'label': 'sentiment',
        'value': sentiment,  # positive, negative, neutral
        'confidence': 0.85
    })
    
    # ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜
    category = classify_review_category(review['content'])
    labels.append({
        'label': 'category',
        'value': category,
        'confidence': 0.90
    })
    
    # í’ˆì§ˆ í‰ê°€
    quality_keywords = extract_quality_keywords(review['content'])
    labels.append({
        'label': 'quality_aspects',
        'value': quality_keywords,
        'confidence': 0.78
    })
    
    # DBì— ì €ì¥
    await db.execute(
        """
        INSERT INTO data_labels (data_type, data_id, labels, labeled_by)
        VALUES ('review', $1, $2, NULL)
        """,
        review_id, json.dumps(labels)
    )
    
    return labels
```

---

**ë¬¸ì„œ ê´€ë¦¬**
- ì‘ì„±ì: ì¥ì¬í›ˆ
- ìµœì¢… ì—…ë°ì´íŠ¸: 2025-11-19
- ì—°ê´€ ë¬¸ì„œ: í”Œë«í¼ ì•„í‚¤í…ì²˜, Backend ê´€ë¦¬ì ì‹œìŠ¤í…œ, ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ


